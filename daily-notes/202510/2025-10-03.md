# 2025-10-02

## 학습

- "Effective Java 3/E" 강의 자료 만들기
    
### 아이템 10. equals() 는 일반 규약을 지켜 재정의하라

- equals() 메서드를 재정의하지 말아야 하는 경우를 확인하였다.
    - 각 인스턴스가 고유한 경우
    - 값을 표현하는 것이 아니라 동작하는 객체를 표현하는 클래스인 경우
    - 인스턴스의 논리적 동치성을 비교할 일이 없는 경우
    - 상위 클래스가 재정의한 equals() 메서드가 하위 클래스에서도 적절한 경우
    - 클래스가 private 이거나 package-private 이고, equals()를 호출할 일이 없는 경우
- equals() 메서드를 재정의할 때 지켜야 할 일반 규약을 확인하였다.
    - 반사성(reflexive)
    - 대칭성(symmetric)
        - x.equals(y) 가 true 라면, y.equals(x) 도 true 여야 한다.
    - 추이성(transitive)
        - x.equals(y) 가 true 이고, y.equals(x) 도 true 라면, x.equals(z) 도 true 여야 한다.
    - 일관성(consistency)
        - x.equals(y) 가 true 라면, 언제나 true 여야 한다.
        - x.equals(y) 가 false 라면, 언제나 false 여야 한다.
    - null-아님(nullity)
        - null 인지 따로 검사할 필요가 없다. 그냥 instanceof 연산자를 사용하면 된다.
- equals() 메서드를 재정의할 때 고려할 사항을 확인하였다.
    - 메서드를 재정의 하는 방법
    - 타입에 따라 필드를 비교하는 방법
    - 성능을 높이기 위한 필드 비교 순서
    - equals() 메서드를 재정의 한 다음 반드시 단위 테스트로 검증할 것!
    - equals() 메서드를 재정의 할 때 메서드 시그너처를 잘못 작성하는 실수를 하지 말 것!


## 참고

### SOLID 원칙 중 Liskov Substitution Principle (LSP)

- 로버트 C. 마틴(Robert C. Martin)이 제안한 **객체지향 설계의 5가지 기본 원칙** 중 하나이다.
- 서브타입은 언제나 자신의 기반 타입(상위 클래스/인터페이스)으로 교체할 수 있어야 한다.
- 즉, 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않고 기반 클래스의 인스턴스로 교체할 수 있어야 한다.
- 이를 위해 서브타입은 기반 타입이 기대하는 행위를 반드시 지켜야 한다.
- 예를 들어, 기반 클래스에서 null이 아닌 값을 반환한다고 약속했다면, 서브타입에서 null을 반환해서는 안된다.
- LSP를 지키지 않으면, 다형성을 활용한 코드에서 예기치 않은 동작이 발생할 수 있다.

### 상속 vs 컴포지션

- 기능 확장의 또 다른 방법으로 컴포지션(composition)이 있다.
- 컴포지션은 기존 클래스를 포함(combine)하여 새로운 기능을 구현하는 방법이다.
- 상속과 컴포지션의 차이점
    - 상속은 is-a 관계를 나타내고, 컴포지션은 has-a 관계를 나타낸다.
    - 상속은 코드 재사용에 초점을 맞추고, 컴포지션은 객체 간의 관계에 초점을 맞춘다.
    - 상속은 강한 결합도를 가지며, 컴포지션은 느슨한 결합도를 가진다.
- 컴포지션의 장점
    - 유연성: 런타임에 객체를 교체할 수 있어, 기능 확장이 용이하다.
    - 캡슐화: 내부 구현을 숨길 수 있어, 변경에 대한 영향을 최소화할 수 있다.
    - 다중 상속 문제 회피: 자바는 다중 상속을 지원하지 않지만, 컴포지션을 사용하면 다중 상속의 효과를 낼 수 있다.
- 결론
    - 상속은 강한 결합도를 가지므로, 신중하게 사용해야 한다.
    - 가능하면 컴포지션을 우선적으로 고려하는 것이 좋다.