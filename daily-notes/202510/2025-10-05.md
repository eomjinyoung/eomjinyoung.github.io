# 2025-10-05

## 학습

- "Effective Java 3/E" 강의 자료 만들기
    
### 아이템 14. Comparable을 구현할지 고려하라

- Comparable 인터페이스의 compareTo() 메서드가 사용되는 상황을 String 클래스의 예제를 통해 이해 했다.
- String 클래스를 통해 compareTo() 메서드의 규약이 무엇인지 확인했다.
- compareTo() 와 equals() 가 일관되지 않았을 때 발생할 수 있는 문제점을 간단한 클래스를 정의하여 확인했다.
    - 또한 자바에서 기본으로 제공하는 BigDecimal 클래스를 사용한 예제를 통해 확인했다.
- 간단한 클래스를 통해 compareTo() 메서드 규약에 맞춰 compareTo() 메서드를 작성해 보았다.
- 자바에서 제공하는 Comparator 인터페이스를 활용하여 compareTo() 메서드를 구현해 보았다.

### 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라

- 정보 은닉의 이점을 이해 했다.
- 접근 제한자 사용에 대해 기본 원칙을 확인했다.
- top-level 클래스/인터페이스의 접근 제한자와 멤버의 접근 제한자 사용을 확인했다.
- 접근 범위를 지정할 때 주의할 점을 확인했다.
- public static final 배열 필드의 문제점과 해결책을 예제를 통해 확인했다.
- 모듈의 목적과 모듈을 사용할 때 접근 제한자의 범위가 어떻게 적용되는지 이해했다.

### 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

- public 클래스에서 public 필드를 사용하지 말아야 하는 이유를 이해 했다.
- public 클래스에서 필드는 private 으로 선언하고, 접근자 메서드를 제공하는 예를 사용하는 것 더 좋은 이유를 확인했다.
    - 메서드를 통해 필드의 값을 바꾸는 방식은 메서드 후크 기능을 활용할 수 있다.
- package-private 클래스나 private 중첩 클래스에서는 public 필드를 사용해도 괜찮은 이유를 이해 했다.

### 아이템 17. 변경 가능성을 최소화하라

- 불변 클래스가 무엇이고 어떻게 만드는지 이해 했다.
  - 불변 클래스의 장점을 확인했다.
  - 불변 클래스를 만드는 5가지 규칙을 확인했다.
- final 필드의 의미를 이해했다.
  - Java Memory Model에서 final 필드에 대한 초기화 보장을 확인했다.
  - 명령어 재배치로 인해 일반 필드 초기화가 지연될 수 있음을 이해했다.
  

## 참고

### Java Language Specification Spec., 17.5 Final Field Semantics

- final 필드의 값은 생성자 끝나기 전에 반드시 초기화가 완료된다.
- 다른 스레드가 레퍼런스를 획득한 후에 final 필드의 값을 읽을 때, 그 값이 초기화된 상태임이 보장된다.
- 그럼 일반 필드는 생성자 호출이 끝난 후에도 초기화되어 있지 않을 수 있는가?
    - 그렇다! 
    - 왜? CPU 캐시, 레지스터, 명령어 재배치 때문이다.

### 명령어 재배치

컴파일러나 CPU는 성능 최적화를 위해 명령어 순서를 재배치할 수 있다.
```java
// 원래 코드
public FinalFieldExample() {
    x = 3;  // final 필드
    y = 4;  // 일반 필드
}

static void writer() {
    f = new FinalFieldExample();
}
```

다음과 같이 재배치 될 수 있다.
```java
// writer() 를 실행할 때
1. 인스턴스 메모리 할당
2. f = 새로 할당된 객체 주소
3. x = 3
4. y = 4
```

Java Memory Model은 final 필드에 대해 다음을 보장한다.
```java
생성자 끝 --> 메모리 장벽(memory barrier) --> f에 참조 발행
// 메모리 장벽이란? 
// 객체가 공개된 이후에 다른 스레드에서도 반드시 보이도록 가시성을 보장한다는 뜻
```

이 내용을 결합하여 명령어 재배치를 고려하면 다음고 같을 수 있다.
```java
// 가능한 시나리오 1
STORE x, 3       // final 필드
[메모리 장벽]
STORE f, 객체주소
STORE y, 4        // 일반 필드

// 가능한 시나리오 2
STORE y, 4        // 일반 필드
STORE x, 3       // final 필드
[메모리 장벽]
STORE f, 객체주소

// 가능한 시나리오 3
STORE x, 3       // final 필드
[메모리 장벽]
STORE y, 4        // 일반 필드
STORE f, 객체주소
```

이런 이유로 다른 스레드가 레퍼런스 f를 획득한 후에,
- x를 읽으면 항상 3이 나온다.
- y를 읽으면 0 또는 4가 나올 수 있다.