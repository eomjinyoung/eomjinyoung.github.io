# 2025-10-19

## 학습

- "Effective Java 3/E" 강의 자료 만들기
    

### 아이템 49. 매개변수가 유효한지 검사하라

- 매개변수 검사의 중요성을 확인하였다.
- 매개변수 검사의 일반적인 방법들을 확인하였다.
    - requireNonNull 메서드를 사용하여 null 검사를 수행하는 방법
    - 범위 검사를 수행하는 Objects의 메서드들을 사용하는 방법
- assert 문을 사용하여 매개변수를 검사하는 방법에 대해 알아보았다.
    - assert 문은 개발 및 테스트 단계에서만 활성화되므로, 운영 환경에서는 매개변수 검사가 수행되지 않는다.
    - 따라서 assert 문은 매개변수 검사를 위한 주된 수단으로 사용해서는 안 된다.

### 아이템 50. 적시에 방어적 복사본을 만들라

- 방어적 복사의 필요성을 확인하였다.
    - 가변 객체를 매개변수로 받을 때
    - 가변 객체를 반환할 때
- 방어적 복사를 구현하는 방법을 확인하였다.
    - 매개변수로 받은 가변 객체를 복사하여 필드에 저장하는 방법
    - 가변 객체를 반환할 때 복사본을 반환하는 방법

### 아이템 51. 메서드 시그너처를 신중히 설계하라

- 메서드 시그너처 설계의 중요성을 확인하였다.
- 메서드 이름을 신중히 선택하는 방법을 확인하였다.
- 매개변수의 목록을 짧게 유지하는 방법을 확인하였다.
    - 메서드를 여러 개로 분리하여 매개변수 목록을 줄이는 방법(직교성을 높인다)
    - 매개변수 객체를 사용하여 관련 매개변수를 그룹화하는 방법
    - 빌더 패턴을 사용하여 많은 매개변수를 처리하는 방법
- 매개변수 타입으로 인터페이스를 사용하는 장점을 확인하였다.
- boolean 보다는 열거 타입을 사용하는 장점을 확인하였다.

### 아이템 52. 다중정의는 신중히 사용하라

- 다중정의(overloading) 메서드를 사용할 때 발생할 수 있는 문제점을 확인하였다.
- 재정의(overriding)과 다중정의(overloading)의 차이점을 확인하였다.
  - 재정의는 런타임에서 타입을 확인하여 호출할 메서드를 결정한다.
  - 다중정의는 컴파일타임에 타입을 확인하여 호출할 메서드를 결정한다.
- 다중정의 메서드로 정의할 때 주의할 점을 확인하였다.
    - 오토박싱으로 인한 모호성을 확인했다.
    - 람다와 메서드 레퍼런스를 사용할 떄 발생할 수 있는 문제점을 확인하였다.
- 다중정의 메서드로 정의할 때 고려할 점을 확인하였다.
    - 근본적으로 타입이 다르면 모호성은 발생하지 않는다.

### 아이템 53. 가변인수는 신중히 사용하라

- 가변인수(varargs) 메서드의 장점을 확인하였다.
- 가변인수 메서드를 작성할 때 주의할 점을 확인하였다.
    - 필수 매개변수는 가변인수 매개변수 앞에 위치시켜야 한다.
    - 매개변수가 1개 이상인 경우에 가변인수 메서드를 작성하는 방법.
    - 매개변수의 개수가 사용되는 상황에 따라 메서드 다중정의와 가변인수 메서드를 함께 사용하는 방법.

### 아이템 54. null이 아닌, 빈 컬렉션이나 배열을 반환하라

- null을 반환할 때 발생할 수 있는 문제점을 확인하였다.
- 빈 컬렉션이나 배열을 반환하는 장점을 확인하였다.
    - null 검사를 하지 않아도 된다.
    - 클라이언트 코드가 더 간결해진다.
- 빈 배열을 반환할 때 성능을 높이는 방법을 확인하였다.
    - 상수 빈 배열을 반환하는 방법
- toArray 메서드를 사용할 때 성능을 높이는 방법을 확인하였다.
    - toArray(new T[size]) 형태로 호출할 때 성능이 떨어질 수 있음을 확인하였다.

## 참고

### 직교성(Orthogonality)

- 수학에서 온 용어로 서로 직각을 이루며 교차한다는 뜻이다.
  수학 관점에서 직교하는 요소들은 서로 독립적이다.
- '직교성이 높다'의 의미:
  "공통점이 없는 기능들이 잘 분리되어 있다"
  "기능을 원자적으로 쪼개 제공한다"
- '직교성을 높혀 오히려 메서드 수를 줄여주는 효과도 있다'의 의미:
  기능을 원자적으로 쪼개다 보면, 자연스럽게 중복이 줄고 결합성이 낮아져 코드를 수정하기 수월해진다.
  기본 기능을 잘만 갖춰놓으면 아무리 복잡한 기능도 조합해낼 수 있다.
  마치 화학의 원소를 가지고 조립하여 다양한 물질을 만들어내는 것과 비슷하다.
  테스트하기 쉬워지고, 가볍고 구현하기 쉽고 유연하고 강력하다.

### 직교성이 낮은 경우

- 편의성을 높인다는 생각에 고수준의 복잡한 기능(직교성이 낮은 기능)을 하나씩 추가하다 보면,
  부지불식간에 눈덩이처럼 커진 API가 만들어질 수 있다.
- 특정 조합(원자적 기능의 조합)의 패턴이 상당히 자주 사용되거나 최적화하여 선능을 개선할 수 있다면,
  직교성이 낮아지더라도 편의기능을 제공하는 편이 나을 수도 있다.

### toArray() 메서드를 잘 사용하는 팁

- toArray(new T[0]) vs toArray(new T[size])
  - toArray(new T[0])가 더 성능이 좋다.
- toArray(new T[0])이 성능이 더 좋은 이유
  - 길이가 0인 배열을 넘기면 JDK 구현은 내부에서 정확한 크기의 새 배열을 한 번만 만들고, JIT이 이 경로를 잘 최적화(escape analysis, 배열 복사 경로 단순화 등)하는 경우가 많다. 
  - 큰 배열(정확 크기 또는 그 이상)을 미리 만들어 넘기면, 다음을 수행하기 떄문에 오버헤드가 발생할 수 있다.
    - 길이 비교 분기,
    - (길이가 큰 경우) a[size] = null 쓰기,
    - 호출 지점에서의 배열 생성 비용(이미 한 번 생성했음)
  - 어차피 결과를 담을 정확한 크기의 배열 하나는 반드시 필요합니다.
    - 미리 만들면 호출자 쪽에서 1회 할당
    - new T[0]를 넘기면 toArray 안에서 1회 할당
    - 할당 횟수는 결국 1회이며, 후자의 경로가 JIT에 의해 더 잘 최적화되는 사례가 많다.
  - 연구/벤치마크 결과
    - 여러 JDK 버전에서의 벤치마크(마이크로벤치 포함)에서 toArray(new T[0])가 동등하거나 더 빠른 경우가 흔했고, “정확 크기의 배열을 미리 만들어 넘기는” 미세 최적화는 오히려 느려질 수 있음이 반복적으로 관찰되었다.

```java
// Java 11+ 환경에서 권장되는 사용법
// 정확 크기의 배열을 JDK가 한 번만 생성. 타입 안전·가독성·성능 모두 우수.
String[] arr = list.toArray(String[]::new);

// Java 8~10 환경에서 권장되는 사용법
String[] arr = list.toArray(new String[0]);
```