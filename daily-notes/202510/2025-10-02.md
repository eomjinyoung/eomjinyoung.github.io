# 2025-10-02

## 학습

- "Effective Java 3/E" 강의 자료 만들기
    
### 아이템 8: finalizer와 cleaner는 피하라

- finalizer와 cleaner 방식으로 자원을 해제시키는 예를 각각 만들어 보았다.
    - 예제를 통해 그 동작 방식을 확인하였다.
- finalizer 방식의 대안으로 Java 9에서 cleaner가 추가되었다고 한다.
    - finalizer 방식과 cleaner 방식의 차이점을 비교해 보았다.
- finalizer와 cleaner의 대안인 AutoCloseable 방식으로 자원을 해제 시키는 예를 만들어 보았다.
    - try-with-resources 구문을 사용하여 자원을 자동으로 해제시키는 방법을 확인하였다.
    - 안전망으로서 cleaner를 함께 사용하는 방법도 확인하였다.

### 아이템 9. try-finally 보다는 try-with-resources를 사용하라

- try-finally 구문을 사용하여 자원을 해제시킬 때 발생할 수 있는 문제점을 확인하였다.
    - try 블록에서 발생한 예외가 호출자에게 전달되지 않고 finally 블록에서 발생한 예외가 전달될 수 있다.
    - 두 개 이상의 자원을 해제시킬 때 코드가 복잡해진다.
- try-with-resources 구문을 사용하여 자원을 해제시키는 방법을 확인하였다.
    - try 블록에서 발생한 예외가 호출자에게 그대로 전달된다.
    - try-with-resources 구문을 사용하면 try-finally 구문을 사용하는 것 보다 코드가 간결해진다.
    - 두 개 이상의 자원을 해제시킬 때도 코드가 간결해진다.
- 결론
    - 가능한 try-with-resources 구문을 사용하는 것이 좋다.

### 아이템 10. equals() 는 일반 규약을 지켜 재정의하라

- equals() 메서드를 재정의하지 말아야 하는 경우를 확인하였다.
    - 각 인스턴스가 고유한 경우
    - 값을 표현하는 것이 아니라 동작하는 객체를 표현하는 클래스인 경우
    - 인스턴스의 논리적 동치성을 비교할 일이 없는 경우
    - 상위 클래스가 재정의한 equals() 메서드가 하위 클래스에서도 적절한 경우
    - 클래스가 private 이거나 package-private 이고, equals()를 호출할 일이 없는 경우
- equals() 메서드를 재정의할 때 지켜야 할 일반 규약을 확인하였다.
    - 반사성(reflexive)
    - 대칭성(symmetric)
        - x.equals(y) 가 true 라면, y.equals(x) 도 true 여야 한다.
    - 추이성(transitive)
    - 일관성(consistency)
    - null-아님(nullity)


## 참고

### Finalizer vs Cleaner

- Finalizer 방식의 문제점
    - 비결정적 실행 시점
        - GC가 객체를 “수거 가능”으로 표시한 뒤에만 finalize()가 호출됩니다.
        - 언제 실행될지 보장되지 않고, 심지어 아예 실행되지 않을 수도 있습니다.
    - 성능 문제
        - Finalizer 큐를 처리하는 단일 스레드가 막히면 다른 객체들의 finalize() 실행도 지연됩니다.
        - 따라서 대기열이 쌓여 메모리 누수로 이어질 수 있습니다.
    - 보안 문제
        - finalize() 안에서 객체를 다시 다른 곳에 등록해 “부활(resurrection)”시킬 수 있습니다.
        - 이러면 “이미 소멸 예정인 객체”가 다시 살아나 예측 불가능한 동작을 유발합니다.
    - GC 부하 증가
        - Finalizer가 붙은 객체는 두 번 GC 사이클을 거쳐야 회수됩니다.
          (1차: 수거 대상 표시 → finalize 큐 등록, 2차: finalize 실행 후 다시 참조 없으면 실제 수거)
- Cleaner 방식의 장점
    - 명시적·안전한 API
        - Cleaner.register(obj, runnable) 형태로 객체와 정리 작업을 연결합니다.
        - 실행되는 것은 사용자가 등록한 별도 Runnable이며, 객체 자체의 메서드를 다시 실행하는 게 아님 → 객체 “부활” 위험 없음.
    - 멱등성 보장
        - Cleanable.clean()을 직접 호출할 수도 있고, GC 후 자동 호출될 수도 있습니다.
        - 둘 중 무엇이 먼저 실행되더라도 Runnable은 단 한 번만 실행됩니다.
    - try-with-resources와 병행 가능
        - AutoCloseable로 명시적 자원 해제를 지원하면서,
        - 혹시 놓친 경우를 대비해 Cleaner를 백업 안전망(safety net) 으로 쓸 수 있습니다.
        - Finalizer는 이런 보조적 사용에 적합하지 않았습니다.
    - 성능 및 단순성
        - Finalizer처럼 객체를 부활시키지 않으므로, 수거 과정이 단순하고 효율적입니다.
        - GC와 Finalizer의 복잡한 상호작용이 줄어듭니다.