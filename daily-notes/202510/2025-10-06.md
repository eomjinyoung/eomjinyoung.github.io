# 2025-10-06

## 학습

- "Effective Java 3/E" 강의 자료 만들기
    

### 아이템 17. 변경 가능성을 최소화하라(계속)

- 불변 클래스가 무엇이고 어떻게 만드는지 이해 했다.
  - 불변 클래스의 장단점을 확인했다.
  - 불변 클래스를 만드는 5가지 규칙을 확인했다.
- final 필드의 의미를 이해했다.
  - Java Memory Model에서 final 필드에 대한 초기화 보장을 확인했다.
  - 명령어 재배치로 인해 일반 필드 초기화가 지연될 수 있음을 이해했다.
- 불변 객체를 다룰 때 함수형 프로그래밍 스타일의 이점을 확인했다.
  - 함수형 프로그래밍과 명령형/절차적 프로그래밍의 차이를 이해했다.
  - 함수형 프로그래밍의 장단점을 이해했다.
- 불변 객체의 특징을 확인했다.
- 불변 클래스를 만드는 방법을 확인했다.
  - final 클래스
  - private 생성자 + 정적 팩토리
- 신뢰할 수 없는 외부로부터 가변 객체를 파라미터로 받을 때 방어적 복사를 수행해야 함을 이해했다.
  
  
## 참고

### 함수형 프로그래밍 vs 명령형/절차적 프로그래밍

- 함수형 프로그래밍: "입력을 바꾸지 않는 순수 함수를 합성해 새 값을 만든다"
    - 상태와 변경: 불변 데이터 선호, 기존 값을 바꾸지 않고 새 값을 반환.
    - 부작용: 순수 함수(같은 입력 -> 항상 같은 출력, 외부 상태 변경 없음)를 기본으로 하고, 부작용은 경계(Edge)로 격리.
    - 참조 투명성: 순수 함수는 식을 값으로 치환해도 의미가 동일 -> 추론, 테스트가 쉬움.
    - 제어 흐름 vs 식(Expression): map / filter / reduce 같은 선언형 구성과 함수 합성.
    - 동시성 내성: 불변 + 순수 함수 덕에 데이터 경합이 줄어 병렬화가 쉬움.
    - 성능 관점: 새 객체 생성이 많아 질 수 있어 단기적으로 **할당/GC 비용**이 생김(대신 안전/병렬성 이점).
- 명령형/절차적 프로그래밍: "상태를 바꾸는 명령들을 순서대로 실행"
    - 상태와 변경: 변수, 객체 상태를 직접 변경.
    - 부작용: I/O, 로그, 전역 변경 등 부작용이 코드 전반에 퍼져 있음.
    - 참조 투명성: 내부 상태나 시간 순서에 의존해 치환이 어렵다.
    - 제어 흐름 vs 식(Expression): for/while, if, 변수 갱신.
    - 동시성 내성: 공유 상태 보호(락/공기화) 비용이 듦.
    - 성능 관점: in-place 변경으로 메모리 효율이 좋을 수 있음(대신 버그.경합 위험).

```java
// 명령형 프로그래밍
int sum = 0;
for (int x : nums) {
  if (x % 2 == 0) {
    int sq = x * x;
    sum += sq;
  }
}
```

```java
// 함수형 프로그래밍
int sum = nums.stream()
              .filter(x -> x % 2 == 0)
              .map(x -> x * x)
              .reduce(0, Integer::sum);

// 원본 nums는 변경되지 않음. 
// 각 단계가 새 값을 만들어 전달한다.
```