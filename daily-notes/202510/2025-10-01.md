# 2025-10-01

## 학습

- "Effective Java 3/E" 강의 자료 만들기
    
### 아이템 2: 생성자에 매개 변수가 많다면 빌더를 고려하라

- record 문법을 사용하면 불변 객체를 좀 더 쉽게 만들 수 있다.
- 물론 Java 16 이상에서만 가능하다.

### 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

- 정적 유틸리티 클래스나 싱글턴으로는 의존 객체를 변경하기 번거롭다.
    - 즉 의존 객체를 바꾸려면 해당 클래스의 코드를 변경해야 하기 때문이다.
- 의존 객체 주입(Dependency Injection, DI) 패턴을 사용하면 의존 객체를 외부에서 주입할 수 있다.
    - 외부에서 주입하는 방식을 사용하면 의존 객체를 바꾸기 쉽다.
    - 그러면 테스트 할 때는 Mock 객체로 바꿀 수 있어, 테스트 코드 작성이 훨씬 쉬워진다.
- DI 프레임워크로는 Spring Framework, Google Guice, Dagger 등이 있다.
    - Guice나 Dagger는 사용해보지 않았다.
- 의존 객체 주입할 때 직접 객체를 주입하는 대신,
    - 팩토리를 주입하는 방법을 구현해 봤다.
    - 자바에서 제공하는 Supplier<T> 인터페이스와 메서드 레퍼런스를 활용하여 팩토리를 주입해 봤다. 

### 아이템 6. 불필요한 객체 생성을 피하라

- 동일한 객체를 반복해서 생성하는 것은 메모리 낭비이고, 성능 저하를 초래할 수 있다.
    - 특히 불변 객체(immutable object)는 재사용이 필수다.
    - String 클래스나 Boolean 클래스를 가지고 예제로 만들어 확인해 봤다.
- 객체 재사용이 성능 향상에 정말 도움이 되는지를 확인하기 위해 벤치마크 테스트를 통해 확인해 봤다.
    - 객체 생성에 비용이 많이 드는 경우에 특히 효과가 있기 때문에, 
      정규표현식에 사용되는 Pattern 인스턴스를 생성하는 예를 가지고 테스트 했다.
    - 실행하는데 걸린 시간을 측정해 보니 6배 안팎의 차이가 났다.
      물론 이것은 객체 생성 비용의 크기에 따라 달라질 것이다.
- 자바 원시 타입(primitive type)과 wrapper 클래스를 혼용할 때 주의해야 한다.
    - 오토 박싱 과정에서 객체 생성이 일어나기 때문에 성능에 영향을 줄 수 있다.

### 아이템 7. 다 쓴 객체 참조를 해제하라

- 스택에서 pop()을 할 때 단순히 인덱스만 줄이고 참조를 두면 안된다.
    - 참조를 null로 만들어 주어야 한다.
    - 그래야 가비지 컬렉터가 해당 객체를 회수할 수 있다.
- 캐시, 풀, 맵 등도 메모리 누수를 일으키는 주범이다.
    - 다 쓴 참조를 그냥 두기 때문에 메모리 누수가 발생한다.
    - 늘 다 쓴 참조를 제거할 수 있도록 주의를 기울여야 한다.
- 다 쓴 참조를 자동으로 제거하는 방법으로 WeakHashMap을 많이 사용한다.
    - WeakHashMap은 키를 WeakReference로 감싸서 저장하기 때문에,
      키에 대한 강한 참조가 없으면 가비지 컬렉터가 해당 엔트리를 회수한다.
    - 주로 캐시나 리스너/콜백 관리에 사용된다.
    - WeakHashMap은 HashMap과 비교해서 이해하는 것이 좋다.


## 참고

### Spring Framework vs Google Guice vs Dagger 비교

- Spring Framework
    - 가장 널리 사용되는 DI 프레임워크
    - DI 외에도 AOP, 트랜잭션 관리, MVC 웹 프레임워크 등 다양한 기능 제공
    - 설정이 복잡할 수 있음 (XML, Java Config, 어노테이션 등 다양한 방식 지원)
    - 런타임에 프록시 생성 등으로 인해 성능 오버헤드가 있을 수 있음
- Google Guice
    - 구글에서 개발한 경량 DI 프레임워크
    - 어노테이션 기반 설정으로 비교적 간단하고 직관적
    - 런타임에 프록시를 생성하지 않아 Spring보다 성능이 더 좋을 수 있음
    - Spring에 비해 기능이 제한적 (예: AOP 지원이 없음)
- Dagger
    - 컴파일 타임에 의존성 그래프를 생성하는 DI 프레임워크
    - 런타임 오버헤드가 거의 없음 (프록시 생성 없음)
    - Android 개발에서 많이 사용됨
    - 설정이 다소 복잡할 수 있음 (컴파일 타임에 그래프 생성)
    - Spring이나 Guice에 비해 기능이 제한적 (예: AOP 지원이 없음)
- 요약
    - Spring Framework: 가장 기능이 풍부하고 널리 사용되지만 설정이 복잡하고 런타임 오버헤드가 있을 수 있음
    - Google Guice: 경량이고 설정이 간단하며 Spring보다 성능이 좋을 수 있지만 기능이 제한적
    - Dagger: 컴파일 타임 DI로 런타임 오버헤드가 거의 없지만 설정이 복잡하고 기능이 제한적
- 선택 기준
    - 프로젝트 규모와 복잡성
    - 팀의 기술 스택과 경험
    - 성능 요구사항
    - 추가로 필요한 기능 (AOP, 트랜잭션 관리 등)


### HashMap vs WeakHashMap

- 예제를 통해 그 차이점을 확인한다.

### java.lang.ref.WeakReference

- 자바에서 약한 참조(weak reference)를 구현하는 클래스를 제공하고 있다.
- 예제를 통해 그 동작 방식을 확인한다.
