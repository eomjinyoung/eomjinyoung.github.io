# 2025-10-11

## 학습

- "Effective Java 3/E" 강의 자료 만들기
    

### 아이템 36. 비트 필드 대신 EnumSet을 사용하라

- 비트 필드 기법으로 여러 상수를 조합하는 방법의 문제점을 확인했다.
  - 비트 연산이 직관적이지 않다.
  - 새로운 상수를 추가할 때마다 비트 연산 코드를 수정해야 한다.
  - 비트 필드의 크기가 제한적이다.
- 비트 필드 대신 EnumSet을 사용하는 방법을 확인했다.
  - EnumSet은 열거 타입 상수의 집합을 표현하는 데 특화된 Set 구현체이다.
  - EnumSet은 내부적으로 비트 벡터를 사용하여 메모리를 효율적으로 사용한다.
  - EnumSet은 타입 안전성을 제공한다.
  - EnumSet은 다양한 집합 연산 메서드를 제공한다.

### 아이템 37. ordinal 인덱싱 대신 EnumMap을 사용하라

- 열거 타입의 ordinal() 메서드를 사용하여 배열의 인덱스를 다룰 때 발생하는 문제점을 확인했다.
  - 열거 상수의 선언 순서에 의존하는 코드는 유지보수가 어렵다.
  - 열거 상수 사이에 새로운 상수를 추가하면 기존 코드가 깨질 수 있다.
  - 배열을 제네릭과 함께 사용하면 타입 안전성이 깨진다.
- EnumMap을 사용하여 열거 타입 상수를 키로 사용하는 방법을 확인했다.
  - EnumMap은 열거 타입을 키로 사용하는 데 최적화된 Map 구현체이다.
  - EnumMap은 내부적으로 배열을 사용하여 메모리를 효율적으로 사용한다.
  - EnumMap은 타입 안전성을 제공한다.
- EnumMap에 Stream을 활용하여 코드를 간결하게 만드는 것을 배웠다.
- 2차원 배열 + ordinal() 방식을 사용했을 때와 중첩 EnumMap을 사용했을 때의 차이점을 비교해 보았다.
  - 코드가 훨씬 간결해지고 열거 타입의 상수를 추가하거나 제거할 때도 안전하다. 

### 아이템 38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라

- 열거 타입이 인터페이스를 구현하게 하여 열거 타입의 상수 객체를 인터페이스 타입으로 다루는 방법을 확인했다.
  - 인터페이스를 구현한 열거 타입을 여러 개 만들 수 있다.
  - 이를 통해 열거 타입을 확장하는 효과를 얻을 수 있다.

### 아이템 39. 명명 패턴보다 애너테이션을 사용하라

- 명명 패턴의 문제점을 이해했다.
  - 전통적으로 도구나 프레임워크가 특별히 다룰 프로그램 요소를 구분하는 방법으로 명명 패턴을 사용해 왔다.
    - 예: JUnit 3의 테스트 메서드 이름은 "test"로 시작해야 한다.
  - 명명 패턴은 코드의 가독성을 떨어뜨리고 유지보수를 어렵게 만든다.
- 명령 패턴 대신 애너테이션을 사용하는 방법으로 프로그램 요소를 다루는 방법을 확인했다.
  - 애너테이션을 정의하고 적용하고, 추출하여 활용하는 방법을 배웠다.
- 애너테이션의 파라미터를 추가하여 다루는 방법을 배웠다.
- @Repeatable 애너테이션을 사용하여 동일한 애너테이션을 여러 번 적용하는 방법을 배웠다.
  - 반복 가능 애너테이션을 만드는 방법.
  - 반복 가능 애너테이션이 적용되었을 때, 애너테이션의 존재 여부를 확인하는 방법.
  - 반복 가능 애너테이션이 적용되었을 때, 애너테이션을 추출하는 방법.
  
### 아이템 40. @Override 애너테이션을 일관되게 사용하라

- @Override 애너테이션을 달지 않았을 때 발생할 수 있는 문제점을 확인했다.
  - 오타로 인해 메서드를 제대로 재정의하지 못한 경우.
  - 상위 클래스의 메서드 시그니처가 변경되어 재정의가 깨지는 경우.
- @Override 애너테이션을 일관되게 사용하는 것이 좋은 이유를 이해했다.
  - 코드의 가독성을 높이고, 유지보수를 쉽게 만든다.
  - IDE의 @Override 기능을 활성화하면, 재정의할 의도가 없는 메서드를 재정의하려 할 때 경고를 받을 수 있다.

### 아이템 41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라

- 마커 인터페이스를 사용할 때와 마커 애너케이션을 사용할 때 어떤 차이가 있는지 확인했다.
  - 두 문법의 적절한 사용 사례를 이해했다.

### 아이템 42. 익명 클래스보다는 람다를 사용하라

- 익명 클래스와 람다 표현식, 비교자 생성 메서드와의 비교를 통해 람다 표현식의 장점을 이해했다.
  - 코드가 간결해지고 가독성이 높아진다.
  - 익명 클래스와 달리 람다는 자신을 둘러싼 문맥(캡처된 변수)을 명확하게 표현한다.
  - 람다는 함수형 인터페이스를 구현하는 데 특화되어 있다.
- 람다 표현식이 유용한 부분과 익명 클래스를 사용해야 하는 부분을 구분하는 기준을 이해했다.
  - 람다는 함수형 인터페이스를 구현할 때 사용한다.
  - 익명 클래스는 함수형 인터페이스가 아닌 인터페이스나 추상 클래스를 구현할 때 사용한다.
  - 익명 클래스는 복잡한 로직이 필요한 경우에 사용한다.


### 아이템 43. 람다보다는 메서드 참조를 사용하라

- 람다 표현식보다 메서드 참조를 사용하는 것이 더 나은 경우와 그 이유를 확인했다.
  - 파라미터 개수가 많거나, 람다 본문이 복잡한 경우.
- 메서드 참조보다 람다 표현식을 사용하는 것이 더 좋은 경우를 확인했다.
  - 같은 클래스에 람다가 있는 경우에는 메서드 레퍼런스보다 가독성이 더 좋다.
  - 코드의 의도가 더 명확히 드러난다.
- 메서드 레퍼런스 유형 5가지를 확인했다.
  - 정적 메서드 레퍼런스
  - 특정 객체의 인스턴스를 사용하는 메서드 레퍼런스
  - 특정 타입의 임의 객체의 인스턴스 메서드 레퍼런스
  - 생성자 레퍼런스
  - 배열 생성자 레퍼런스

## 참고

### 