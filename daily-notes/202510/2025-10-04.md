# 2025-10-04

## 학습

- "Effective Java 3/E" 강의 자료 만들기
    
### 아이템 11. equals()를 재정의하려거든 hashCode()도 재정의하라

- Object 명세에 제시된 hashCode() 메서드에 대한 규약을 확인했다.
    - equals()에 사용되는 정보가 변경되지 않았다면, hashCode()는 항상 같은 값을 반환해야 한다.
    - equals()가 true를 반환하는 두 객체에 대해, 같은 hashCode() 값을 반환해야 한다.
    - equals()가 false를 반환하는 두 객체에 대해, 같은 hashCode() 값을 반환할 수도 있다.
     (하지만, 해시 기반 컬렉션의 성능을 위해, 다른 객체는 다른 값을 반환하라.)
- hashCode() 메서드를 재정의하지 않았을 때와 재정의 했을 때의 차이를 확인했다.
    - HashMap에 객체를 저장하고 꺼낼 때 hashCode()와 equals() 메서드를 사용한다.
- 해시 값이 사용되는 상황을 확인했다.
    - 해시 값은 해시 테이블의 버킷을 결정하는 데 사용된다.
    - 해시 값이 동일한 객체들이 같은 버킷에 저장될 수 있다(충돌).
    - 충돌이 발생하면, 해당 버킷에 연결 리스트나 트리 구조를 사용하여 여러 객체를 저장한다.
    - 객체를 검색할 때도 동일한 해시 코드를 사용하여 버킷을 찾고, 그 버킷 내에서 equals() 메서드를 사용하여 정확한 객체를 찾는다.
    - 이것이 hashCode()를 재정의해야 하는 이유이다.
- hashCode() 메서드 작성법 확인했다.
    - 해시 코드 계산 방법에 따라 작성한다.
- Lombok 라이브러리를 사용하여 hashCode() 메서드를 자동 생성하는 방법을 확인했다.
    - Gradle에서 Lombok 플러그인을 추가한다.
    - 클래스를 정의할 때 `@EqualsAndHashCode` 어노테이션을 사용한다.

### 아이템 12. toString을 항상 재정의하라

- toString() 메서드를 재정의하지 않았을 때와 재정의 했을 때의 차이를 확인했다.
    - toString() 메서드를 재정의하지 않으면, 클래스 이름과 해시 코드가 포함된 문자열이 반환된다.
    - toString() 메서드를 재정의하면, 객체의 상태를 나타내는 유용한 문자열을 반환할 수 있다.
- Lombok 라이브러리를 사용하여 toString() 메서드를 자동 생성하는 방법을 확인했다.
    - `@ToString` 어노테이션을 사용한다.
    - `@Getter` 어노테이션은 필드의 값을 꺼내는 접근자 메서드를 자동 생성한다.
- toString() 메서드를 재정의하지 말아야 할 경우를 확인했다.
    - enum 타입은 자바에서 자동으로 toString()을 재정의해 준다.
    - 정적 유틸리티 클래스는 인스턴스를 만들 일이 없으므로 toString()을 재정의할 필요가 없다.

### 아이템 13. clone 재정의는 주의해서 진행하라

- 객체 복제를 수행하는 방법을 확인했다.
    - Object의 clone() 메서드를 재정의 한다.
    - Cloneable 인터페이스를 구현한다.
- 얕은 복사와 깊은 복사의 차이를 확인했다.
    - 얕은 복사: 객체의 필드 값만 복사한다. (참조 타입 필드는 참조 값만 복사)
    - 깊은 복사: 객체의 필드 값과 참조 타입 필드가 가리키는 객체까지 복사한다.
- clone() 메서드를 재정의할 때 규칙을 확인했다.
    - CloneNotSupportedException 예외 처리는 제거한다.
    - 접근 제어자는 public 으로 변경한다.
    - 리턴 타입은 복제할 클래스 타입으로 변경한다.
    - super.clone()을 호출하여 복제본을 얻는다.
- 복사 생성자와 복사 팩터리를 사용하여 객체를 복제하는 방법을 확인했다.
    - 변환 생성자와 변환 팩터리를 사용하면 원본 타입에 얽매이지 않고 복제본의 타입을 자유롭게 선택할 수 있다.


## 참고

### 해시 테이블의 버킷과 해시 코드

- 해시 테이블은 내부적으로 배열을 사용한다.
- 해시 테이블에 객체를 저장할 때, 객체의 hashCode() 메서드를 호출하여 정수 해시 코드를 얻는다.
- 이 해시 코드를 배열의 인덱스로 변환하여 객체를 저장할 위치(버킷)를 결정한다.
    - 일반적으로 `index = hashCode % array.length` 방식으로 인덱스를 계산한다.
- 해시 코드가 동일한 객체들이 같은 버킷에 저장될 수 있다(충돌).
- 충돌이 발생하면, 해당 버킷에 연결 리스트나 트리 구조를 사용하여 여러 객체를 저장한다.
- 객체를 검색할 때도 동일한 해시 코드를 사용하여 버킷을 찾고, 그 버킷 내에서 equals() 메서드를 사용하여 정확한 객체를 찾는다.
- 따라서, hashCode()와 equals() 메서드가 올바르게 구현되어야 해시 테이블이 제대로 동작한다.

### Java의 HashMap

- Java 8부터 HashMap은 충돌이 많이 발생하는 버킷에 대해 연결 리스트 대신 트리 구조를 사용하여 성능을 향상시킨다.
- 이때 트리 구조는 **레드-블랙 트리**를 사용한다.
- 한 버킷에 연결된 노드 수가 8이상이면 레드-블랙 트리로 변환하고, 6이하로 줄어들면 다시 연결 리스트로 되돌린다.

### 레드-블랙 트리(Red-Black Tree)

- "레드-블랙 트리"는 자가 균형 이진 탐색 트리(Self-balancing Binary Search Tree)의 일종이다.
- 일반적인 이진 탐색 트리(BST)는 삽입/삭제가 반복되면 한쪽으로 치우쳐져 성능이 O(n)까지 떨어지 수 있다.
- 레드-블랙 트리는 다음과 같은 규칙을 통해 트리의 균형을 유지한다.
    - 각 노드는 빨간색 또는 검은색이다.
    - 루트 노드는 항상 검은색이다.
    - 모든 리프 노드(NIL 노드)는 검은색이다.
    - 빨간색 노드의 자식은 모두 검은색이다(즉, 빨간색 노드는 연속해서 나타날 수 없다).
    - 어떤 노드에서 그 자손 리프 노드에 이르는 모든 경로에는 동일한 수의 검은색 노드가 포함되어야 한다.
- 이러한 규칙 덕분에 레드-블랙 트리는 삽입과 삭제 연산 후에도 트리의 높이가 O(log n)로 유지된다.
- 따라서, 레드-블랙 트리를 사용하면 최악의 경우에도 효율적인 탐색, 삽입, 삭제가 가능하다. 