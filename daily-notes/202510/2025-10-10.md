# 2025-10-09

## 학습

- "Effective Java 3/E" 강의 자료 만들기
    

### 아이템 26. 로 타입(raw types)은 사용하지 말라

- raw type이 무엇인지 확인했다.
- raw type을 사용했을 때 발생할 수 있는 문제점을 확인했다.
  - 컴파일러가 타입 검사를 하지 않기 때문에, 잘못된 타입이 들어갈 수 있다.
  - 타입 안전성이 깨진다.
- 제네릭 타입과 parameterized type의 사용법을 확인했다.
- unbound wildcard type의 필요성을 확인했다.
- raw type을 써도 되는 예외 상황을 확인했다.

### 아이템 27. 비검사 경고를 제거하라

- 컴파일할 때 비검사 경고가 발생하면 반드시 제거해야 함을 이해했다.
- 컴파일러가 비검사 경고를 상세하게 보고하도록 옵션을 설정하는 방법을 확인했다.
  - Gradle에서 컴파일러 옵션을 설정하는 방법을 확인했다.
- 애노테이션을 활용하여 비검사 경고를 무시하는 방법을 확인했다.
  - `@SuppressWarnings("unchecked")` 애노테이션 사용법을 확인했다.

### 아이템 28. 배열보다는 리스트를 사용하라

- 제네릭 타입의 배열을 만들 수 없는 이유를 이해했다.
  - 배열의 공변성이 제네릭 타입의 불변성과 충돌하기 때문이다.
- 배열로 제네릭 타입을 다루기 보다는 리스트로 다루는 것이 좋음을 확인했다.

### 아이템 29. 이왕이면 제네릭 타입으로 만들어라

- 새로운 타입을 설계할 때는 제네릭 타입으로 만드는 것이 좋음을 이해했다.
  - 예제를 통해 기존 코드를 제네릭으로 전환하는 방법을 확인했다.
- 기존 클래스를 제네릭 타입으로 바꿔도 기존 코드를 깨뜨리지 않음을 확인했다.
  - 오히려 새로운 사용자를 편하게 해주는 방법이다.

### 아이템 30. 이왕이면 제네릭 메서드로 만들라

- 일반 메서드와 제네릭 메서드의 차이를 이해했다.
- 제네릭 메서드를 만드는 방법을 확인했다.
- 한정적 와일드카드 타입으로 제네릭 메서드를 만드는 방법을 확인했다.
  - 단순 제네릭 메서드에 비해 더 유연하게 사용할 수 있음을 이해했다.
- 항정 함수가 무엇인지 이해했다.
  - 제네릭 메서드로 항정 함수를 반환하는 방법을 확인했다.
- 재귀적 타입 한정(recursive type bound)이 무엇인지 이해했다.
  - Comparable<T> 를 통해 재귀적 타입 한정 메서드를 구현하고 사용하는 것을 확인했다.

### 아이템 31. 한정적 와일드카드를 사용해 API 유연성을 높이라

- 제네릭 타입은 불변성을 가지므로 유연성이 떨어질 수 있음을 확인했다.
  - 서로 다른 Type1과 Type2가 있을 때, Generic<Type1>과 Generic<Type2>는 서로 호환되지 않는 것을 안다.
- 한정적 와일드카드 타입을 사용하면 제네릭 타입의 유연성을 높일 수 있음을 예제를 통해 확인했다.
  - <? extends T> 와일드카드 타입
  - <? super T> 와일드카드 타입
- 메서드 선언에 type parameter가 한 번만 나오면 와일드카드로 대체하는 것이 좋은 이유를 이해했다.
  - 와일드카드 타입을 사용하면 더 간단하고 직관적이다.
  - 도우미 제네릭 메서드를 사용하여 와일드카드 타입의 제네릭 메서드를 public API로 제공하는 방법을 확인했다.

## 참고

### Optional<T> 활용법

- Optional<T> 클래스는 null이 될 수 있는 값을 감싸는 컨테이너 역할을 한다.
- Optional<T> 클래스의 주요 메서드
  - static <T> Optional<T> empty(): 빈 Optional 객체를 반환한다.
  - static <T> Optional<T> of(T value): null이 아닌 값을 감싸는 Optional 객체를 반환한다. value가 null이면 NullPointerException이 발생한다.
  - static <T> Optional<T> ofNullable(T value): null이 될 수 있는 값을 감싸는 Optional 객체를 반환한다. value가 null이면 빈 Optional 객체를 반환한다.
- Optional<T> 객체에서 값을 꺼내는 방법
  - T get(): 값을 반환한다. 값이 없으면 NoSuchElementException이 발생한다.
  - T orElse(T other): 값이 있으면 값을 반환하고, 없으면 other를 반환한다.
  - T orElseGet(Supplier<? extends T> other): 값이 있으면 값을 반환하고, 없으면 other.get()을 호출하여 반환한다.
  - <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier): 값이 있으면 값을 반환하고, 없으면 exceptionSupplier.get()을 호출하여 예외를 던진다.