# 2025-10-10

## 학습

- "Effective Java 3/E" 강의 자료 만들기
    

### 아이템 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라

- 가변인수 파라미터 메서드의 구동 방식을 이해했다.
- 제네릭 가변인수 파라미터의 문제점을 확인했다.
- 제네릭 가변인수 파라미터 메서드를 안전하게 만드는 방법을 확인했다.
- @SafeVarargs 어노테이션 용도를 확인했다.

### 아이템 33. 타입 안전 이종 컨테이너를 고려하라

- 일반적인 컨테이너는 단일 타입의 객체만 담을 수 있음을 이해했다.
  - 예: List<String> 은 String 타입의 객체만 담을 수 있다.
- 타입 안전 이종 컨테이너는 서로 다른 타입의 객체를 담을 수 있음을 확인했다.
  - 제네릭 Class 객체와 타입 토큰을 사용하여 타입 안전성을 확보한다.
  - Favorites 클래스 예제를 통해 구현 방법을 이해했다.
- 한정적 타입 토큰을 사용하여 특정 타입의 서브타입만 담도록 제한하는 방법을 확인했다.
  - 한정적 타입 파라미터로 구현하는 방법과 한정적 와일드카드 타입으로 구현하는 방법을 비교해 보았다.

### 아이템 34. int 상수 대신 열거 타입을 사용하라

- 정수 상수 패턴을 사용할 때의 문제점이 무엇인지 에제를 통해 확인했다.
- 열거 타입의 기본 사용법을 확인했다.
- 열거 타입의 고급 사용법을 확인했다.
  - 필드, 메서드, 생성자를 정의할 수 있다.
  - 추상 메서드를 정의하고 각 열거 상수에서 구현할 수 있다.
  - 인터페이스를 구현할 수 있다.
  - toString()를 재정의 할 수 있다.
  - values() 메서드로 모든 열거 상수를 배열로 얻을 수 있다.
  - valueOf() 메서드를 이용해 이름으로 열거 상수를 얻을 수 있다
- 중첩 열거 타입을 정의하고 사용하는 방법을 확인했다.
  - 전략 열거 타입 패턴을 구현하는 방법을 배웠다.

### 아이템 35. ordinal 메서드 대신 인스턴스 필드를 사용하라

- ordinal() 메서드의 용도와 잘못 사용했을 때 발생할 수 있는 문제점을 확인했다.
  - 열거 상수의 선언 순서에 의존하는 코드는 유지보수가 어렵다.
  - 열거 상수 사이에 새로운 상수를 추가하면 기존 코드가 깨질 수 있다.
- 열거 타입에 인스턴스 필드를 추가하여 ordinal() 메서드 대신 사용하는 방법을 확인했다.
  - 인스턴스 필드를 final로 선언하여 불변성을 유지한다.
  - 생성자를 통해 상수와 연결된 인스턴스 필드를 초기화 한다.


## 참고

### AtomicReference<T> 클래스

- 멀티스레드 환경에서 단일 객체 참조를 원자적으로 읽고 쓸 수 있게 해주는 클래스이다.
- 동기화(synchronized) 블록을 사용하지 않고도 스레드 안전하게 객체 참조를 변경하거나 교체할 수 있도록 설계된 lock-free 유틸리티이다.
- 내부적으로 volatile 필드 하나를 갖고 있다.
- 단순히 "값 하나를 저장" 하지만, CAS(Compare-And-Set) 연산을 통해 여러 스레드가 동시에 접근하더라도 원자적(atomic)으로 갱신된다.
- 여러 스레드가 같은 객체 참조를 바꾸려고 경쟁할 때 lock 없이 안전하게 "누가 성공했는지" 판별하고 값을 교체한다.
- sysnchronized 대신 CAS 기반 원자 연산을 사용해 성능과 안전성을 동시에 확보한다.